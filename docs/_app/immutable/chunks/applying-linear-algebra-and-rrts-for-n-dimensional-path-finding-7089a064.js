import{S as qn,i as In,s as Ln,k as o,q as l,a as p,l as s,m as u,r,h as t,c,K as x,n as f,b as n,E as i,B as Oa}from"./index-106a4746.js";function Nn(h){let w,le,B,E,A,P,q,I,Be,Ee,Ae,Pe,qe,Ie,L,N,za,Le,Ne,Ge,De,je,Oe,ze,G,re,Mt,We,D,Ht,Ue,Ce,Se,j,pe,Ft,Me,d,Vt,ue,Yt,Xt,ce,Kt,$t,fe,Jt,Qt,O,Wa,He,_,Zt,me,ea,ta,Fe,v,z,de,aa,na,oa,R,he,sa,ia,we,la,ra,pa,ve,ua,Ve,m,ca,W,Ua,fa,ke,ma,da,U,Ca,ha,C,Sa,wa,Ye,Xe,Ke,S,va,$e,Je,Qe,M,H,Ma,Ze,et,tt,g,ka,be,ba,ya,at,nt,ot,F,ye,_a,st,V,Ra,it,lt,rt,Y,ga,pt,ut,ct,X,_e,xa,ft,K,Ta,mt,dt,ht,T,An=`<code class="language-python">Auxiliary Functions <span class="token punctuation">(</span>the implementation of these vary by use<span class="token operator">-</span><span class="token keyword">case</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token operator">-</span> get_random_valid_vertex<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Returns a random<span class="token punctuation">,</span> valid vertex<span class="token punctuation">.</span>
<span class="token operator">-</span> random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> returns a random value between <span class="token number">0</span> <span class="token keyword">and</span> <span class="token number">1.</span>
<span class="token operator">-</span> check_path_validity<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span> Returns whether <span class="token keyword">or</span> <span class="token keyword">not</span> a path <span class="token keyword">is</span> valid<span class="token punctuation">.</span>
<span class="token operator">-</span> euclidean_norm<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span> Returns the euclidean norm of x<span class="token punctuation">.</span>
<span class="token operator">-</span> get_nearest_point<span class="token punctuation">(</span>nodes<span class="token punctuation">,</span> q_rand<span class="token punctuation">)</span><span class="token punctuation">:</span> Returns the nearest point <span class="token keyword">and</span> path<span class="token punctuation">.</span>
<span class="token operator">-</span> get_path<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span> Returns a path <span class="token keyword">from</span> x to y<span class="token punctuation">.</span>
<span class="token operator">-</span> Node<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Holds a point <span class="token keyword">and</span> path

<span class="token operator">//</span> A function to implement our <span class="token string">'Next Point'</span> formula <span class="token keyword">from</span> above<span class="token punctuation">.</span>
func next_point<span class="token punctuation">(</span>from_vector<span class="token punctuation">,</span> to_vector<span class="token punctuation">,</span> delta_q<span class="token punctuation">)</span><span class="token punctuation">:</span>
	new_vec <span class="token operator">=</span> to_vector <span class="token operator">-</span> from_vector
	euclidean_dist <span class="token operator">=</span> euclidean_norm<span class="token punctuation">(</span>new_vector<span class="token punctuation">)</span>
	<span class="token keyword">if</span> euclidean_distance <span class="token operator">></span> delta_q<span class="token punctuation">:</span>
		new_vec <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>new_vec <span class="token operator">/</span> euclidean_dist<span class="token punctuation">)</span> <span class="token operator">*</span> delta_q<span class="token punctuation">)</span> <span class="token operator">+</span> from_point
	<span class="token keyword">return</span> new_vec

<span class="token operator">//</span> Our RRT implementation<span class="token punctuation">.</span>
func rrt<span class="token punctuation">(</span>starting_point<span class="token punctuation">,</span> goal_point<span class="token punctuation">,</span> num_samples<span class="token punctuation">,</span> nodes<span class="token punctuation">,</span> delta_q<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">for</span> <span class="token number">1</span> to number_of_samples<span class="token punctuation">:</span>
		q_rand <span class="token operator">=</span> get_random_valid_vertex<span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token operator">//</span> Using <span class="token number">50</span><span class="token operator">%</span> <span class="token keyword">as</span> the randomness percentage <span class="token keyword">for</span> exploration<span class="token punctuation">.</span>
		<span class="token keyword">if</span> random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0.5</span><span class="token punctuation">:</span>
			q_rand <span class="token operator">=</span> goal_point
		near_point <span class="token operator">=</span> get_nearest_point<span class="token punctuation">(</span>point_list<span class="token punctuation">,</span> q_rand<span class="token punctuation">)</span>
		next_path <span class="token operator">=</span> path<span class="token punctuation">(</span>next_point<span class="token punctuation">(</span>near_point<span class="token punctuation">,</span> q_rand<span class="token punctuation">,</span> delta_q<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> check_path_validity<span class="token punctuation">(</span>next_path<span class="token punctuation">)</span> <span class="token keyword">is</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
			add Node <span class="token keyword">with</span> point <span class="token keyword">and</span> path to nodes

			<span class="token keyword">if</span> point <span class="token keyword">is</span> within acceptable distance to goal point<span class="token punctuation">:</span>
				<span class="token keyword">break</span>
	<span class="token keyword">return</span> nodes</code>`,wt,vt,kt,bt,b,Ba,$,Ha,Ea,J,Fa,yt,_t,Rt,Q,Re,Aa,gt,Z,Pa,xt,Tt,Bt,ee,ge,qa,Et,te,Ia,At,ae,La,Pt,qt,It,ne,Na,Lt,Nt,Gt,oe,Ga,Dt,jt,Ot,se,Da,zt,Wt,Ut;return{c(){w=o("p"),le=l("First, I apologize for the formatting of this post. I am going to try modifying the back-end rendering to get better results."),B=p(),E=o("br"),A=l(`
There are many path-finding algorithms for a whole slew of applications. Many are commonly discussed such as breadth-first search, depth-first search, Dijkstra's, A*, Bellman-Ford, and more. Some more optimal and efficient than others, but all crucial to the advancement of path-finding and graph traversal in the field of computer science. These algorithms permeated into other areas where we now use them in our everyday lives, with tools such as GPS navigation while driving or even looking up a file on our computers. However, as powerful as they are, these algorithms are hard, and many inefficient, to implement outside of a 2-dimensional space. Some applications, such as mapping a road, are just fine remaining in 2-dimensions, but there are many problems that need to be solved that have n-dimensions exceeding just 2. 
`),P=o("br"),q=o("br"),I=l(`
Rapidly-exploring Random Trees (RRTs) fill this void. A RRT is a search algorithm that efficiently searches nonconvex, n-dimensional spaces by branching out and exploring that space. That's a lot to define. First, what does searching a nonconvex, n-dimensional space look like and mean? 
`),Be=o("br"),Ee=o("br"),Ae=l(`
N-dimensional spaces are spaces that have an undefined dimension. In designing algorithms to accomodate more than just a single dimension we are creating a solution that is modular and scalable.  A convex set in geometry and linear algebra is a subset of the euclidean space in which a line XY connecting points X and Y in the set lies entirely within that set. More simply, you are at a point A and you need to get to a point B. If you can walk from A to B in a straight line then this is a convex set. Inversely, a nonconvex set is one where a valid path from A to B is not possible with just a straight line.
`),Pe=o("br"),qe=o("br"),Ie=p(),L=o("p"),N=o("img"),Le=p(),Ne=o("br"),Ge=o("br"),De=l(`
Now that we know we are dealing with getting from point A to point B in a nonconvex set, how do we go about implementing RRT to get a valid path?
`),je=o("br"),Oe=o("br"),ze=p(),G=o("p"),re=o("strong"),Mt=l("Getting the Next Point"),We=p(),D=o("p"),Ht=l("Before we can go about finding a path from point A to point B we have to be able to go from one point to the next. We can start by defining a valid 2-dimensional solution and then rebuilding it as an n-dimensional model."),Ue=p(),Ce=o("br"),Se=p(),j=o("p"),pe=o("strong"),Ft=l("2D Point Creation"),Me=p(),d=o("p"),Vt=l("We are going to assume that our result is valid, and this is because following the creation of a point in our algorithm we will ensure its validity. Knowing that we want to get from A to B and that we are in a convex set we likely won\u2019t be able to travel the full distance from our current position to the goal position. We will choose a portion of this distance and refer to it as "),ue=o("code"),Yt=l("delta_q"),Xt=l(", meaning that if a distance from our current point to the next point is greater than "),ce=o("code"),Kt=l("delta_q"),$t=l(" then that distance will be reduced to a distance of "),fe=o("code"),Jt=l("delta_q"),Qt=l(`. An example of A and B in a cartesian space may look like:
`),O=o("img"),He=p(),_=o("p"),Zt=l("We will say that our start position is A = (0,0) and our goal position is B = (6,4), and we will treat these not as ordered coordinate pairs but as vectors. How do we get from A to a distance, at most, "),me=o("code"),ea=l("delta_q"),ta=l(" away from A on the path to B? There are several things that we need to compute first:"),Fe=p(),v=o("ol"),z=o("li"),de=o("code"),aa=l("V"),na=l(" , a new vector from B - A."),oa=p(),R=o("li"),he=o("code"),sa=l("||V||"),ia=l(", The euclidean norm of "),we=o("code"),la=l("V"),ra=l(". Note that the norm of a vector in a normed vector space is also the magnitude."),pa=p(),ve=o("li"),ua=l("The unit vector of our new vector."),Ve=p(),m=o("p"),ca=l(`Now that we know what we need to compute for we can apply it in a general formula:
`),W=o("img"),fa=l(`
Applying this to our current points A and B with a value of `),ke=o("code"),ma=l("delta_q = 2"),da=l(`we get:
`),U=o("img"),ha=l(`
Which, when applied to our graph, looks like:
`),C=o("img"),wa=l(`
This means that our next point is the purple point on the path from A to B.`),Ye=p(),Xe=o("br"),Ke=p(),S=o("p"),va=l("Now that we have our working formula it is relatively easy to expand it to n-dimensions. We are already working with vectors which are n-dimensional. By opening up the formula to accept n-dimensions with our goal point being vector G and our starting point being vector S we get:"),$e=p(),Je=o("br"),Qe=p(),M=o("p"),H=o("img"),Ze=p(),et=o("br"),tt=p(),g=o("p"),ka=l("It is important to note that this formula is only applied when the euclidean distance from our starting point to our goal point exceeds the value of "),be=o("code"),ba=l("delta_q"),ya=l(", whatever we may set that to. Also, you may have noticed that this only creates points in a straight line along the path from our start point to the end point. How does this help us in a nonconvex space?"),at=p(),nt=o("br"),ot=p(),F=o("p"),ye=o("strong"),_a=l("Introducing Randomness"),st=p(),V=o("p"),Ra=l("RRTs work by navigating some percentage of time towards a random, valid point rather than the goal point. This allows for the search to branch out and become an exploring tree rather than just a straight line, therefore accomodating nonconvex spaces."),it=p(),lt=o("br"),rt=l(`
Let's say that we set a random exploration goal of 20%. This means that 20% of the time the algorithm will explore other points in the space and the remaining 80% of the time it will be working its way towards the goal point. Regardless of whether we are navigating towards a random point or a goal point we will still be utilizing the 'Next Point' formula above, just in that instance the goal point may be random instead of the true end goal.
`),Y=o("p"),ga=l("Depending on your goal, space, and other factors you can introduce randomness into your algorithm at different levels. Your use case may require more exploration while other may require less. Picking an exploration percentage requires intimate knowledge of your space as well as a fair bit of trial and error."),pt=p(),ut=o("br"),ct=p(),X=o("p"),_e=o("strong"),xa=l("Building Our RRT"),ft=p(),K=o("p"),Ta=l("We have our formulas and needed variables, now let\u2019s implement a RRT in pseudo-code."),mt=p(),dt=o("br"),ht=p(),T=o("pre"),wt=p(),vt=o("br"),kt=o("br"),bt=p(),b=o("p"),Ba=l(`Once fully implemented, this RRT can successfully search a given space. It can even be modified to solely explore without having a given goal point. Here is a picture of the algorithm searching a space and finding a goal while avoiding obstacles.
`),$=o("img"),Ea=p(),J=o("img"),yt=p(),_t=o("br"),Rt=p(),Q=o("p"),Re=o("strong"),Aa=l("Real World Applications"),gt=p(),Z=o("p"),Pa=l("RRT is commonly applied in motion planning for robotics and autonomous driving where there are numerous dimensions to consider. Linear algebra can be applied to get distances between not only physical objects, but also any sort of reading that you choose to apply it to. Linear algebra, for example, is the basis of artificial intelligence, neural networks, and machine learning. Efficiency in algorithms is what enables further jumps in science not only in areas like autonomous driving, but also in gene and disease research."),xt=p(),Tt=o("br"),Bt=p(),ee=o("p"),ge=o("strong"),qa=l("RRT Variations and Concluding Remarks"),Et=p(),te=o("p"),Ia=l("The RRT implementation introduced here is not optimal, it is the base implementation. Numerous other RRT variations have been introduced over the years that build upon RRT and optimize it to another level of efficiency."),At=p(),ae=o("p"),La=l("- A*-RRT searches low-dimensional spaces for solutions before moving to higher-dimensions."),Pt=p(),qt=o("br"),It=p(),ne=o("p"),Na=l("- Informed RRT* utilizes an admissable ellipsoidal heuristic for more efficiency."),Lt=p(),Nt=o("br"),Gt=p(),oe=o("p"),Ga=l("- RRT with Dynamics utilizes motion dynamics as dimensions to determine feasible motion paths while moving."),Dt=p(),jt=o("br"),Ot=p(),se=o("p"),Da=l("- Parallelized RRT utilizes parallelization to search for valid paths in less time."),zt=p(),Wt=o("br"),Ut=l(`
These are just several examples of how RRT can not only be implemented, but optimized. Being able to traverse multiple dimensions of input and data for optimal paths and states has helped us advance the field of robotics and autonomous driving. What further optimizations can be made, and where will it take us next?`),this.h()},l(e){w=s(e,"P",{});var a=u(w);le=r(a,"First, I apologize for the formatting of this post. I am going to try modifying the back-end rendering to get better results."),a.forEach(t),B=c(e),E=s(e,"BR",{}),A=r(e,`
There are many path-finding algorithms for a whole slew of applications. Many are commonly discussed such as breadth-first search, depth-first search, Dijkstra's, A*, Bellman-Ford, and more. Some more optimal and efficient than others, but all crucial to the advancement of path-finding and graph traversal in the field of computer science. These algorithms permeated into other areas where we now use them in our everyday lives, with tools such as GPS navigation while driving or even looking up a file on our computers. However, as powerful as they are, these algorithms are hard, and many inefficient, to implement outside of a 2-dimensional space. Some applications, such as mapping a road, are just fine remaining in 2-dimensions, but there are many problems that need to be solved that have n-dimensions exceeding just 2. 
`),P=s(e,"BR",{}),q=s(e,"BR",{}),I=r(e,`
Rapidly-exploring Random Trees (RRTs) fill this void. A RRT is a search algorithm that efficiently searches nonconvex, n-dimensional spaces by branching out and exploring that space. That's a lot to define. First, what does searching a nonconvex, n-dimensional space look like and mean? 
`),Be=s(e,"BR",{}),Ee=s(e,"BR",{}),Ae=r(e,`
N-dimensional spaces are spaces that have an undefined dimension. In designing algorithms to accomodate more than just a single dimension we are creating a solution that is modular and scalable.  A convex set in geometry and linear algebra is a subset of the euclidean space in which a line XY connecting points X and Y in the set lies entirely within that set. More simply, you are at a point A and you need to get to a point B. If you can walk from A to B in a straight line then this is a convex set. Inversely, a nonconvex set is one where a valid path from A to B is not possible with just a straight line.
`),Pe=s(e,"BR",{}),qe=s(e,"BR",{}),Ie=c(e),L=s(e,"P",{});var Va=u(L);N=s(Va,"IMG",{src:!0,alt:!0}),Va.forEach(t),Le=c(e),Ne=s(e,"BR",{}),Ge=s(e,"BR",{}),De=r(e,`
Now that we know we are dealing with getting from point A to point B in a nonconvex set, how do we go about implementing RRT to get a valid path?
`),je=s(e,"BR",{}),Oe=s(e,"BR",{}),ze=c(e),G=s(e,"P",{});var Ya=u(G);re=s(Ya,"STRONG",{});var Xa=u(re);Mt=r(Xa,"Getting the Next Point"),Xa.forEach(t),Ya.forEach(t),We=c(e),D=s(e,"P",{});var Ka=u(D);Ht=r(Ka,"Before we can go about finding a path from point A to point B we have to be able to go from one point to the next. We can start by defining a valid 2-dimensional solution and then rebuilding it as an n-dimensional model."),Ka.forEach(t),Ue=c(e),Ce=s(e,"BR",{}),Se=c(e),j=s(e,"P",{});var $a=u(j);pe=s($a,"STRONG",{});var Ja=u(pe);Ft=r(Ja,"2D Point Creation"),Ja.forEach(t),$a.forEach(t),Me=c(e),d=s(e,"P",{});var y=u(d);Vt=r(y,"We are going to assume that our result is valid, and this is because following the creation of a point in our algorithm we will ensure its validity. Knowing that we want to get from A to B and that we are in a convex set we likely won\u2019t be able to travel the full distance from our current position to the goal position. We will choose a portion of this distance and refer to it as "),ue=s(y,"CODE",{});var Qa=u(ue);Yt=r(Qa,"delta_q"),Qa.forEach(t),Xt=r(y,", meaning that if a distance from our current point to the next point is greater than "),ce=s(y,"CODE",{});var Za=u(ce);Kt=r(Za,"delta_q"),Za.forEach(t),$t=r(y," then that distance will be reduced to a distance of "),fe=s(y,"CODE",{});var en=u(fe);Jt=r(en,"delta_q"),en.forEach(t),Qt=r(y,`. An example of A and B in a cartesian space may look like:
`),O=s(y,"IMG",{src:!0,alt:!0}),y.forEach(t),He=c(e),_=s(e,"P",{});var Ct=u(_);Zt=r(Ct,"We will say that our start position is A = (0,0) and our goal position is B = (6,4), and we will treat these not as ordered coordinate pairs but as vectors. How do we get from A to a distance, at most, "),me=s(Ct,"CODE",{});var tn=u(me);ea=r(tn,"delta_q"),tn.forEach(t),ta=r(Ct," away from A on the path to B? There are several things that we need to compute first:"),Ct.forEach(t),Fe=c(e),v=s(e,"OL",{});var ie=u(v);z=s(ie,"LI",{});var ja=u(z);de=s(ja,"CODE",{});var an=u(de);aa=r(an,"V"),an.forEach(t),na=r(ja," , a new vector from B - A."),ja.forEach(t),oa=c(ie),R=s(ie,"LI",{});var xe=u(R);he=s(xe,"CODE",{});var nn=u(he);sa=r(nn,"||V||"),nn.forEach(t),ia=r(xe,", The euclidean norm of "),we=s(xe,"CODE",{});var on=u(we);la=r(on,"V"),on.forEach(t),ra=r(xe,". Note that the norm of a vector in a normed vector space is also the magnitude."),xe.forEach(t),pa=c(ie),ve=s(ie,"LI",{});var sn=u(ve);ua=r(sn,"The unit vector of our new vector."),sn.forEach(t),ie.forEach(t),Ve=c(e),m=s(e,"P",{});var k=u(m);ca=r(k,`Now that we know what we need to compute for we can apply it in a general formula:
`),W=s(k,"IMG",{src:!0,alt:!0}),fa=r(k,`
Applying this to our current points A and B with a value of `),ke=s(k,"CODE",{});var ln=u(ke);ma=r(ln,"delta_q = 2"),ln.forEach(t),da=r(k,`we get:
`),U=s(k,"IMG",{src:!0,alt:!0}),ha=r(k,`
Which, when applied to our graph, looks like:
`),C=s(k,"IMG",{src:!0,alt:!0}),wa=r(k,`
This means that our next point is the purple point on the path from A to B.`),k.forEach(t),Ye=c(e),Xe=s(e,"BR",{}),Ke=c(e),S=s(e,"P",{});var rn=u(S);va=r(rn,"Now that we have our working formula it is relatively easy to expand it to n-dimensions. We are already working with vectors which are n-dimensional. By opening up the formula to accept n-dimensions with our goal point being vector G and our starting point being vector S we get:"),rn.forEach(t),$e=c(e),Je=s(e,"BR",{}),Qe=c(e),M=s(e,"P",{});var pn=u(M);H=s(pn,"IMG",{src:!0,alt:!0}),pn.forEach(t),Ze=c(e),et=s(e,"BR",{}),tt=c(e),g=s(e,"P",{});var St=u(g);ka=r(St,"It is important to note that this formula is only applied when the euclidean distance from our starting point to our goal point exceeds the value of "),be=s(St,"CODE",{});var un=u(be);ba=r(un,"delta_q"),un.forEach(t),ya=r(St,", whatever we may set that to. Also, you may have noticed that this only creates points in a straight line along the path from our start point to the end point. How does this help us in a nonconvex space?"),St.forEach(t),at=c(e),nt=s(e,"BR",{}),ot=c(e),F=s(e,"P",{});var cn=u(F);ye=s(cn,"STRONG",{});var fn=u(ye);_a=r(fn,"Introducing Randomness"),fn.forEach(t),cn.forEach(t),st=c(e),V=s(e,"P",{});var mn=u(V);Ra=r(mn,"RRTs work by navigating some percentage of time towards a random, valid point rather than the goal point. This allows for the search to branch out and become an exploring tree rather than just a straight line, therefore accomodating nonconvex spaces."),mn.forEach(t),it=c(e),lt=s(e,"BR",{}),rt=r(e,`
Let's say that we set a random exploration goal of 20%. This means that 20% of the time the algorithm will explore other points in the space and the remaining 80% of the time it will be working its way towards the goal point. Regardless of whether we are navigating towards a random point or a goal point we will still be utilizing the 'Next Point' formula above, just in that instance the goal point may be random instead of the true end goal.
`),Y=s(e,"P",{});var dn=u(Y);ga=r(dn,"Depending on your goal, space, and other factors you can introduce randomness into your algorithm at different levels. Your use case may require more exploration while other may require less. Picking an exploration percentage requires intimate knowledge of your space as well as a fair bit of trial and error."),dn.forEach(t),pt=c(e),ut=s(e,"BR",{}),ct=c(e),X=s(e,"P",{});var hn=u(X);_e=s(hn,"STRONG",{});var wn=u(_e);xa=r(wn,"Building Our RRT"),wn.forEach(t),hn.forEach(t),ft=c(e),K=s(e,"P",{});var vn=u(K);Ta=r(vn,"We have our formulas and needed variables, now let\u2019s implement a RRT in pseudo-code."),vn.forEach(t),mt=c(e),dt=s(e,"BR",{}),ht=c(e),T=s(e,"PRE",{class:!0});var Pn=u(T);Pn.forEach(t),wt=c(e),vt=s(e,"BR",{}),kt=s(e,"BR",{}),bt=c(e),b=s(e,"P",{});var Te=u(b);Ba=r(Te,`Once fully implemented, this RRT can successfully search a given space. It can even be modified to solely explore without having a given goal point. Here is a picture of the algorithm searching a space and finding a goal while avoiding obstacles.
`),$=s(Te,"IMG",{src:!0,alt:!0}),Ea=c(Te),J=s(Te,"IMG",{src:!0,alt:!0}),Te.forEach(t),yt=c(e),_t=s(e,"BR",{}),Rt=c(e),Q=s(e,"P",{});var kn=u(Q);Re=s(kn,"STRONG",{});var bn=u(Re);Aa=r(bn,"Real World Applications"),bn.forEach(t),kn.forEach(t),gt=c(e),Z=s(e,"P",{});var yn=u(Z);Pa=r(yn,"RRT is commonly applied in motion planning for robotics and autonomous driving where there are numerous dimensions to consider. Linear algebra can be applied to get distances between not only physical objects, but also any sort of reading that you choose to apply it to. Linear algebra, for example, is the basis of artificial intelligence, neural networks, and machine learning. Efficiency in algorithms is what enables further jumps in science not only in areas like autonomous driving, but also in gene and disease research."),yn.forEach(t),xt=c(e),Tt=s(e,"BR",{}),Bt=c(e),ee=s(e,"P",{});var _n=u(ee);ge=s(_n,"STRONG",{});var Rn=u(ge);qa=r(Rn,"RRT Variations and Concluding Remarks"),Rn.forEach(t),_n.forEach(t),Et=c(e),te=s(e,"P",{});var gn=u(te);Ia=r(gn,"The RRT implementation introduced here is not optimal, it is the base implementation. Numerous other RRT variations have been introduced over the years that build upon RRT and optimize it to another level of efficiency."),gn.forEach(t),At=c(e),ae=s(e,"P",{});var xn=u(ae);La=r(xn,"- A*-RRT searches low-dimensional spaces for solutions before moving to higher-dimensions."),xn.forEach(t),Pt=c(e),qt=s(e,"BR",{}),It=c(e),ne=s(e,"P",{});var Tn=u(ne);Na=r(Tn,"- Informed RRT* utilizes an admissable ellipsoidal heuristic for more efficiency."),Tn.forEach(t),Lt=c(e),Nt=s(e,"BR",{}),Gt=c(e),oe=s(e,"P",{});var Bn=u(oe);Ga=r(Bn,"- RRT with Dynamics utilizes motion dynamics as dimensions to determine feasible motion paths while moving."),Bn.forEach(t),Dt=c(e),jt=s(e,"BR",{}),Ot=c(e),se=s(e,"P",{});var En=u(se);Da=r(En,"- Parallelized RRT utilizes parallelization to search for valid paths in less time."),En.forEach(t),zt=c(e),Wt=s(e,"BR",{}),Ut=r(e,`
These are just several examples of how RRT can not only be implemented, but optimized. Being able to traverse multiple dimensions of input and data for optimal paths and states has helped us advance the field of robotics and autonomous driving. What further optimizations can be made, and where will it take us next?`),this.h()},h(){x(N.src,za=h[0])||f(N,"src",za),f(N,"alt","Convex vs. Non-Convex"),x(O.src,Wa=h[1])||f(O,"src",Wa),f(O,"alt","AB Example"),x(W.src,Ua=h[3])||f(W,"src",Ua),f(W,"alt","2D General"),x(U.src,Ca=h[2])||f(U,"src",Ca),f(U,"alt","2D Applied"),x(C.src,Sa=h[4])||f(C,"src",Sa),f(C,"alt","2D Result Graphed"),x(H.src,Ma=h[5])||f(H,"src",Ma),f(H,"alt","nD Formula"),f(T,"class","language-python"),x($.src,Ha=h[7])||f($,"src",Ha),f($,"alt","RRT Run"),x(J.src,Fa=h[6])||f(J,"src",Fa),f(J,"alt","RRT Goal Run")},m(e,a){n(e,w,a),i(w,le),n(e,B,a),n(e,E,a),n(e,A,a),n(e,P,a),n(e,q,a),n(e,I,a),n(e,Be,a),n(e,Ee,a),n(e,Ae,a),n(e,Pe,a),n(e,qe,a),n(e,Ie,a),n(e,L,a),i(L,N),n(e,Le,a),n(e,Ne,a),n(e,Ge,a),n(e,De,a),n(e,je,a),n(e,Oe,a),n(e,ze,a),n(e,G,a),i(G,re),i(re,Mt),n(e,We,a),n(e,D,a),i(D,Ht),n(e,Ue,a),n(e,Ce,a),n(e,Se,a),n(e,j,a),i(j,pe),i(pe,Ft),n(e,Me,a),n(e,d,a),i(d,Vt),i(d,ue),i(ue,Yt),i(d,Xt),i(d,ce),i(ce,Kt),i(d,$t),i(d,fe),i(fe,Jt),i(d,Qt),i(d,O),n(e,He,a),n(e,_,a),i(_,Zt),i(_,me),i(me,ea),i(_,ta),n(e,Fe,a),n(e,v,a),i(v,z),i(z,de),i(de,aa),i(z,na),i(v,oa),i(v,R),i(R,he),i(he,sa),i(R,ia),i(R,we),i(we,la),i(R,ra),i(v,pa),i(v,ve),i(ve,ua),n(e,Ve,a),n(e,m,a),i(m,ca),i(m,W),i(m,fa),i(m,ke),i(ke,ma),i(m,da),i(m,U),i(m,ha),i(m,C),i(m,wa),n(e,Ye,a),n(e,Xe,a),n(e,Ke,a),n(e,S,a),i(S,va),n(e,$e,a),n(e,Je,a),n(e,Qe,a),n(e,M,a),i(M,H),n(e,Ze,a),n(e,et,a),n(e,tt,a),n(e,g,a),i(g,ka),i(g,be),i(be,ba),i(g,ya),n(e,at,a),n(e,nt,a),n(e,ot,a),n(e,F,a),i(F,ye),i(ye,_a),n(e,st,a),n(e,V,a),i(V,Ra),n(e,it,a),n(e,lt,a),n(e,rt,a),n(e,Y,a),i(Y,ga),n(e,pt,a),n(e,ut,a),n(e,ct,a),n(e,X,a),i(X,_e),i(_e,xa),n(e,ft,a),n(e,K,a),i(K,Ta),n(e,mt,a),n(e,dt,a),n(e,ht,a),n(e,T,a),T.innerHTML=An,n(e,wt,a),n(e,vt,a),n(e,kt,a),n(e,bt,a),n(e,b,a),i(b,Ba),i(b,$),i(b,Ea),i(b,J),n(e,yt,a),n(e,_t,a),n(e,Rt,a),n(e,Q,a),i(Q,Re),i(Re,Aa),n(e,gt,a),n(e,Z,a),i(Z,Pa),n(e,xt,a),n(e,Tt,a),n(e,Bt,a),n(e,ee,a),i(ee,ge),i(ge,qa),n(e,Et,a),n(e,te,a),i(te,Ia),n(e,At,a),n(e,ae,a),i(ae,La),n(e,Pt,a),n(e,qt,a),n(e,It,a),n(e,ne,a),i(ne,Na),n(e,Lt,a),n(e,Nt,a),n(e,Gt,a),n(e,oe,a),i(oe,Ga),n(e,Dt,a),n(e,jt,a),n(e,Ot,a),n(e,se,a),i(se,Da),n(e,zt,a),n(e,Wt,a),n(e,Ut,a)},p:Oa,i:Oa,o:Oa,d(e){e&&t(w),e&&t(B),e&&t(E),e&&t(A),e&&t(P),e&&t(q),e&&t(I),e&&t(Be),e&&t(Ee),e&&t(Ae),e&&t(Pe),e&&t(qe),e&&t(Ie),e&&t(L),e&&t(Le),e&&t(Ne),e&&t(Ge),e&&t(De),e&&t(je),e&&t(Oe),e&&t(ze),e&&t(G),e&&t(We),e&&t(D),e&&t(Ue),e&&t(Ce),e&&t(Se),e&&t(j),e&&t(Me),e&&t(d),e&&t(He),e&&t(_),e&&t(Fe),e&&t(v),e&&t(Ve),e&&t(m),e&&t(Ye),e&&t(Xe),e&&t(Ke),e&&t(S),e&&t($e),e&&t(Je),e&&t(Qe),e&&t(M),e&&t(Ze),e&&t(et),e&&t(tt),e&&t(g),e&&t(at),e&&t(nt),e&&t(ot),e&&t(F),e&&t(st),e&&t(V),e&&t(it),e&&t(lt),e&&t(rt),e&&t(Y),e&&t(pt),e&&t(ut),e&&t(ct),e&&t(X),e&&t(ft),e&&t(K),e&&t(mt),e&&t(dt),e&&t(ht),e&&t(T),e&&t(wt),e&&t(vt),e&&t(kt),e&&t(bt),e&&t(b),e&&t(yt),e&&t(_t),e&&t(Rt),e&&t(Q),e&&t(gt),e&&t(Z),e&&t(xt),e&&t(Tt),e&&t(Bt),e&&t(ee),e&&t(Et),e&&t(te),e&&t(At),e&&t(ae),e&&t(Pt),e&&t(qt),e&&t(It),e&&t(ne),e&&t(Lt),e&&t(Nt),e&&t(Gt),e&&t(oe),e&&t(Dt),e&&t(jt),e&&t(Ot),e&&t(se),e&&t(zt),e&&t(Wt),e&&t(Ut)}}}const jn={title:"Applying Linear Algebra and Rapidly-Exploring Random Trees for N-Dimensional Path-Finding",date:"2022-10-18"};function Gn(h){const w=new URL(""+new URL("../assets/convex_vs_nonconvex-0598ddcb.jpg",import.meta.url).href,self.location).href,le=new URL(""+new URL("../assets/ab_example-40460980.png",import.meta.url).href,self.location).href,B=new URL(""+new URL("../assets/2d_applied-3d35ed6d.png",import.meta.url).href,self.location).href,E=new URL(""+new URL("../assets/2d_general-2fcbf408.png",import.meta.url).href,self.location).href,A=new URL(""+new URL("../assets/2d_res_graphed-09039560.png",import.meta.url).href,self.location).href,P=new URL(""+new URL("../assets/nd_formula-f3b04a6d.png",import.meta.url).href,self.location).href,q=new URL(""+new URL("../assets/rrt_goal_run-e6191554.png",import.meta.url).href,self.location).href,I=new URL(""+new URL("../assets/rrt_run-c9db2607.png",import.meta.url).href,self.location).href;return[w,le,B,E,A,P,q,I]}class On extends qn{constructor(w){super(),In(this,w,Gn,Nn,Ln,{})}}export{On as default,jn as metadata};
